%
% Inertial Measurement Unit and Camera Calibration Toolbox (IMU to CAM rotation and translation calibration):
%
% Rotation calibration:
% It is assumed that IMU and CAM rigid mount is taken through several static poses and sampled at the same time,
% with the chessboard target vertical in all images, and that the corresponing IMU data was sampled for each frame
%
% INPUT: Calib_Results.mat -> Generated by the standard calibration toolbox;
%        images -> 3 digit numbered .bmp with base_name given by Calib_Results
%        imu data -> 3 digit numbered .txt with base_name+'imu' with imu data (mininum 10 lines, ax ay az ... (m.s^2))
%
% OUTPUT: imu2cam.mat -> computed rotation quaternion
%
% Features:
%        -> estimated IMU to CAM rotation quaternion
%        -> input error weighing is used 
%        -> rendered unit sphere projection showing orientation vectors
%           and chessboard vanishing points 
%           (use 'opengl software if you experience rendering problems)
%        -> plot reprojection angular error (angle between imu verticals
%           rotated to cam and vertical vanishing point)
%
% requires:
%         -  robot toolbox by Peter Corke (used here for quaternion and rotation matrix manipulation)
%            (http://www.cat.csiro.au/cmst/staff/pic/robot/)
%         -  TOOLBOX_calib ((c) Jean-Yves Bouguet - Intel Corporation) to generate camera Calib_Results.mat
%            (http://www.vision.caltech.edu/bouguetj/calib_doc/index.html)
%         - fscatter3
%         - clickmove
%         - arrow3
%
% jlobo Jun 2008   updated to use weights and imu text file input
% jlobo April 2004


m=menu('IMU and CAM Calibration Toolbox',...
       'Load camera calibration files',...
       'Quit IMU and CAM Calibration Toolbox');
switch m
  case 1
      load Calib_Results;
      fprintf(1,'\nLoaded calib data for %s image set.\n',calib_name);
  case 2
      break
end
[i frames]=size(image_numbers);
m=menu(sprintf('IMU and CAM Calibration Toolbox\n\nbase name: %s\n\nframes 1 to %d',calib_name,frames),...
       sprintf('Load IMU data (imu###.log)'),...
       'Quit IMU and CAM Calibration Toolbox');
switch m
  case 1
      [imu, imu_w]=load_imu_w(calib_name,frames);
      fprintf(1,'\nLoaded IMU data from %s_###.mat files.\n',calib_name);
  case 2
      break
end
m=menu(sprintf('IMU and CAM Calibration Toolbox\n\nbase name: %s\n\nframes 1 to %d',calib_name,frames),...
       'Run rotation calibration',...
       'Quit IMU and CAM Calibration Toolbox');
switch m
  case 1
      %cam = calc_cam_vp(frames,fc,cc,kc,alpha_c); 
      calc_cam_vp_w; % sets cam, not implemneted as a function to have variables available
      %q=calc_q_imu2cam(imu,cam);  force the use of weights
      qw=calc_q_imu2cam_w(imu, imu_w,cam, cam_w);
      fprintf(1,'\nIMU to CAM Rotation quaternion.\n');
      q=qw
      fprintf(1,'\n');
  case 2
      break
end
n=1;
while 1
	m=menu(sprintf('IMU and CAM Calibration Toolbox\n\nbase name: %s\n\nframes 1 to %d',calib_name,frames),...
           'Show unit sphere and rotation for selected frame',...
           sprintf('next frame (current frame = %d)',n),...
           'Show rotation reprojection error',...
           sprintf('Save rotation quaternion to %simu2cam.mat',calib_name),...
           'Quit IMU and CAM Calibration Toolbox');
	switch m
      case 1
          show_us_vp_cam_imu;
      case 2
          n=n+1;
          if n>frames
              n=1;
          end;    
      case 3    
          %show_rotation_reprojection_error;
          figure('Name','Rotation Reprojection Error');
          angerr=[];
          for i=1:frames
			angerr=[angerr vect_ang(q*imu(i,:)',cam(i,:))];
             if angerr(i)>pi/2
                 angerr(i)=angerr(i)-pi;
             end
		  end
          %To obtain the root-mean-square (RMS) value, use norm(A)/sqrt(n)
          rms_angerr=norm(angerr)/sqrt(frames);
          plot(abs(angerr*180/pi),'r*');
          title(sprintf('Root Mean Square Angle Error %.3f (deg)',180*rms_angerr/pi));
          set(gca,'xtick',image_numbers);
          set(gca,'YGrid','on');
          xlabel('Frames');
          ylabel('Error (deg)');
      case 4
          save imu2cam.mat q;
          fprintf(1,'\nRotation quaternion saved as %simu2cam.mat.\n',calib_name);
		  q
		  Euler_angles=tr2eul(q.T())
		  Roll_Pitch_Yaw_angles=tr2rpy(q.T())
%SUBSREF Reference methods on a QUATERNION object
%  	QUATERNION.d		return a 4-vector of quaternion elements
% 	QUATERNION.s		return the scalar component
% 	QUATERNION.v		return the vector component
% 	QUATERNION.t		return a 4x4 homogeneous transform
% 	QUATERNION.r		return a 3x3 orthonormal rotation matrix
      case 5
          break
	end
end